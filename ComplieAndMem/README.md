

- [Complie And Memeory 编译及内存相关](#complie-and-memeory-编译及内存相关)
- [引用](#引用)

# Complie And Memeory 编译及内存相关


# 引用

问题这个sum的引用指向了哪里？

- left+right的结果存在了哪里
  - 
```C++
int main() {
    int left = 0xff;
    int right = 0xff00;
    const int& sum = left + right;
    return 0;
}
```

使用编译器生成汇编代码
```
cl [filename] /FA
```
从vs上方的 "工具-->命令行-->开发者命令提示"打开命令行。执行
实际命令:
```
D:\srccode\cplusplusdemo\ComplieAndMem\build>cl ..\reference\main.cpp /FA
```
输出为
```
D:\srccode\cplusplusdemo\ComplieAndMem\build>cl ..\reference\main.cpp /FA
用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.29.30148 版
版权所有(C) Microsoft Corporation。保留所有权利。

main.cpp
Microsoft (R) Incremental Linker Version 14.29.30148.0
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:main.exe
main.obj

D:\srccode\cplusplusdemo\ComplieAndMem\build>
```

查看生成的汇编代码文件

main.asm

```asm
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

	TITLE	D:\srccode\cplusplusdemo\ComplieAndMem\build\main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_main
; Function compile flags: /Odtp
_TEXT	SEGMENT
_sum$ = -16						; size = 4
_$S1$ = -12						; size = 4
_right$ = -8						; size = 4
_left$ = -4						; size = 4
_main	PROC
; File D:\srccode\cplusplusdemo\ComplieAndMem\reference\main.cpp
; Line 1
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; Line 2
	mov	DWORD PTR _left$[ebp], 255		; 000000ffH
; Line 3
	mov	DWORD PTR _right$[ebp], 65280		; 0000ff00H
; Line 4
	mov	eax, DWORD PTR _left$[ebp]
	add	eax, DWORD PTR _right$[ebp]
	mov	DWORD PTR _$S1$[ebp], eax
	lea	ecx, DWORD PTR _$S1$[ebp]
	mov	DWORD PTR _sum$[ebp], ecx
; Line 5
	xor	eax, eax
; Line 6
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
END

```