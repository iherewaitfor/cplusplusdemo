

- [Complie And Memeory 编译及内存相关](#complie-and-memeory-编译及内存相关)
- [寄存器](#寄存器)
  - [常见寄存器的分类](#常见寄存器的分类)
- [引用](#引用)
- [函数压栈](#函数压栈)

# Complie And Memeory 编译及内存相关

# 寄存器
## 常见寄存器的分类
1. 通用寄存器（EAX EBX ECX EDX EBP ESP ESI EDI）
   - EAX 累加寄存器
     - 作用：实现乘除运算、中间结果缓存
   - EBX——基址寄存器（Base Register）
     - 作用：存储器指针
   - ECX——计数寄存器（Count Register）
     - 作用：实现循环控制、进行串操作
   - EDX——数据寄存器（Data Register）
     - 作用：实现乘除运算、中间结果缓存（与EAX类似）
   - EBP——基址指针寄存器（Base Pointer Register）
     - 作用：指向栈帧底部或栈底（栈帧底部和栈底是两个不同的概念）
   - ESP——堆栈指针寄存器（Stack Pointer Register）
     - 作用：指向栈帧顶部或栈顶（栈帧顶部和栈顶是两个不同的概念）
2. 段寄存器（CS DS SS ES FS GS）
3. 指令指针寄存器（EIP）
4. 标志寄存器（EFLAGS）

# 引用

问题这个sum的引用指向了哪里？

- left+right的结果存在了哪里
- 引用sum指向了哪里
```C++
int main() {
    int left = 0xff;
    int right = 0xff00;
    const int& sum = left + right;
    return 0;
}
```

使用编译器生成汇编代码
```
cl [filename] /FA
```
从vs上方的 "工具-->命令行-->开发者命令提示"打开命令行。执行
实际命令:
```
D:\srccode\cplusplusdemo\ComplieAndMem\build>cl ..\reference\main.cpp /FA
```
输出为
```
D:\srccode\cplusplusdemo\ComplieAndMem\build>cl ..\reference\main.cpp /FA
用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.29.30148 版
版权所有(C) Microsoft Corporation。保留所有权利。

main.cpp
Microsoft (R) Incremental Linker Version 14.29.30148.0
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:main.exe
main.obj

D:\srccode\cplusplusdemo\ComplieAndMem\build>
```

查看生成的汇编代码文件

main.asm

```asm
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

	TITLE	D:\srccode\cplusplusdemo\ComplieAndMem\build\main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_main
; Function compile flags: /Odtp
_TEXT	SEGMENT
_sum$ = -16						; size = 4
_$S1$ = -12						; size = 4
_right$ = -8						; size = 4
_left$ = -4						; size = 4
_main	PROC
; File D:\srccode\cplusplusdemo\ComplieAndMem\reference\main.cpp
; Line 1
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; Line 2
	mov	DWORD PTR _left$[ebp], 255		; 000000ffH
; Line 3
	mov	DWORD PTR _right$[ebp], 65280		; 0000ff00H
; Line 4
	mov	eax, DWORD PTR _left$[ebp]
	add	eax, DWORD PTR _right$[ebp]
	mov	DWORD PTR _$S1$[ebp], eax
	lea	ecx, DWORD PTR _$S1$[ebp]
	mov	DWORD PTR _sum$[ebp], ecx
; Line 5
	xor	eax, eax
; Line 6
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
END

```

- 栈申请了16个字节
    - sub sub	esp, 16	
    - 分别存储
      - left
      - right
      - left+right的结果临时变量S1
      - sum
- left + right的结果放在栈里
- sum指向了临时变量S1
  - S1也在栈里，就在sum的前面
  - 

给代码加一下注解
```asm
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

	TITLE	D:\srccode\cplusplusdemo\ComplieAndMem\build\main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_main
; Function compile flags: /Odtp
_TEXT	SEGMENT
_sum$ = -16						; size = 4
_$S1$ = -12						; size = 4
_right$ = -8						; size = 4
_left$ = -4						; size = 4
_main	PROC
; File D:\srccode\cplusplusdemo\ComplieAndMem\reference\main.cpp
; Line 1
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H 给栈申请了16个字节空间（栈顶-16、栈由大到小扩展），存储四个变量（如上提示）：left、right、left+right的临时变量、引用sum
; Line 2
	mov	DWORD PTR _left$[ebp], 255		; 000000ffH
; Line 3
	mov	DWORD PTR _right$[ebp], 65280		; 0000ff00H
; Line 4
	mov	eax, DWORD PTR _left$[ebp]
	add	eax, DWORD PTR _right$[ebp]
	mov	DWORD PTR _$S1$[ebp], eax  ;把累加器的值放到S1。即栈在ebp-12的位置
	lea	ecx, DWORD PTR _$S1$[ebp]  ;将S1的值放到计数寄存器ecx
	mov	DWORD PTR _sum$[ebp], ecx  ;将ecx的值放到sum，即栈在ebp -16的位置
; Line 5
	xor	eax, eax
; Line 6
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
END

```

# 函数压栈
int add(int a, int b)

压栈顺序为从右至左，最后是返回值。

b->a->返回值


正面以

Sum add(int a, int b)

为例 

```C++
struct Sum {
    int l;
    int r;
    int h;
};
Sum add(int a, int b){
    Sum s;
    s.l = a;
    s.r = b;
    s.h = a;
    return s;
}
int main() {
    int left = 0xff;
    int right = 0xff00;
    Sum sum = add(left, right);
    return 0;
}
```

这里在关于Sum的构造的调用
- 在add中
  - Sum s。调用了一次构造函数
  - 在函数返回时调用 了一次拷贝构造函数

```asm
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

	TITLE	D:\srccode\cplusplusdemo\ComplieAndMem\build\main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?add@@YA?AUSum@@HH@Z				; add
PUBLIC	_main
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_main
	DD	0dH
	DD	057H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?add@@YA?AUSum@@HH@Z
	DD	0dH
	DD	039H
voltbl	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
$T1 = -48						; size = 12
_left$ = -36						; size = 4
_right$ = -32						; size = 4
_sum$ = -28						; size = 12
$T2 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_main	PROC
; File D:\srccode\cplusplusdemo\ComplieAndMem\reference\main.cpp
; Line 13
	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
; Line 14
	mov	DWORD PTR _left$[ebp], 255		; 000000ffH
; Line 15
	mov	DWORD PTR _right$[ebp], 65280		; 0000ff00H
; Line 16
	mov	eax, DWORD PTR _right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _left$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	?add@@YA?AUSum@@HH@Z			; add
	add	esp, 12					; 0000000cH     弹出调用add的参数列表及返回值地址。
	mov	ecx, DWORD PTR [eax]				;add返回时，已把临时变量T1的地址给了eax。
	mov	DWORD PTR $T2[ebp], ecx             ;以下逻辑是T1值赋给T2,然后，T2赋值为sum
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp+8], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _sum$[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR _sum$[ebp+4], edx
	mov	eax, DWORD PTR $T2[ebp+8]
	mov	DWORD PTR _sum$[ebp+8], eax
; Line 17
	xor	eax, eax
; Line 18
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
_s$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
$T1 = 8							; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
?add@@YA?AUSum@@HH@Z PROC				; add
; File D:\srccode\cplusplusdemo\ComplieAndMem\reference\main.cpp
; Line 6
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
; Line 8
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _s$[ebp], eax
; Line 9
	mov	ecx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _s$[ebp+4], ecx
; Line 10
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR _s$[ebp+8], edx
; Line 11
	mov	eax, DWORD PTR $T1[ebp]    ;把add函数中的本地变量s，赋值给main的临时变量T1。这里取的是T1的地址给eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], ecx       ;把ecx的值传给eax指向的地址。这里eax加了[]
	mov	edx, DWORD PTR _s$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _s$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR $T1[ebp]    ;把T1地址放到寄存器eax
; Line 12
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]    ;add函数退出清理栈
	xor	ecx, ebp
	call	@__security_check_cookie@4      ;检查是否栈溢出
	mov	esp, ebp							;把栈底值ebp，赋给栈顶值esp。
	pop	ebp									;从栈中弹出值给ebp。（这里ebp的值，就是main函数的栈底）
	ret	0
?add@@YA?AUSum@@HH@Z ENDP				; add
_TEXT	ENDS
END

```