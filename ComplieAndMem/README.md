

- [Complie And Memeory 编译及内存相关](#complie-and-memeory-编译及内存相关)
- [寄存器](#寄存器)
	- [常见寄存器的分类](#常见寄存器的分类)
- [引用](#引用)
- [引用折叠](#引用折叠)
- [std::move实现原理](#stdmove实现原理)
- [std::forward实现原理](#stdforward实现原理)
- [简版函数压栈](#简版函数压栈)
- [函数压栈](#函数压栈)

# Complie And Memeory 编译及内存相关

# 寄存器
## 常见寄存器的分类
1. 通用寄存器（EAX EBX ECX EDX EBP ESP ESI EDI）
   - EAX 累加寄存器
     - 作用：实现乘除运算、中间结果缓存
   - EBX——基址寄存器（Base Register）
     - 作用：存储器指针
   - ECX——计数寄存器（Count Register）
     - 作用：实现循环控制、进行串操作
   - EDX——数据寄存器（Data Register）
     - 作用：实现乘除运算、中间结果缓存（与EAX类似）
   - EBP——基址指针寄存器（Base Pointer Register）
     - 作用：指向栈帧底部或栈底（栈帧底部和栈底是两个不同的概念）
   - ESP——堆栈指针寄存器（Stack Pointer Register）
     - 作用：指向栈帧顶部或栈顶（栈帧顶部和栈顶是两个不同的概念）
2. 段寄存器（CS DS SS ES FS GS）
3. 指令指针寄存器（EIP）
4. 标志寄存器（EFLAGS）

# 引用

问题这个sum的引用指向了哪里？

- left+right的结果存在了哪里
- 引用sum指向了哪里
```C++
int main() {
    int left = 0xff;
    int right = 0xff00;
    const int& sum = left + right;
    return 0;
}
```

使用编译器生成汇编代码
```
cl [filename] /FA
```
从vs上方的 "工具-->命令行-->开发者命令提示"打开命令行。执行
实际命令:
```
D:\srccode\cplusplusdemo\ComplieAndMem\build>cl ..\reference\main.cpp /FA
```
输出为
```
D:\srccode\cplusplusdemo\ComplieAndMem\build>cl ..\reference\main.cpp /FA
用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.29.30148 版
版权所有(C) Microsoft Corporation。保留所有权利。

main.cpp
Microsoft (R) Incremental Linker Version 14.29.30148.0
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:main.exe
main.obj

D:\srccode\cplusplusdemo\ComplieAndMem\build>
```

查看生成的汇编代码文件

main.asm

```asm
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

	TITLE	D:\srccode\cplusplusdemo\ComplieAndMem\build\main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_main
; Function compile flags: /Odtp
_TEXT	SEGMENT
_sum$ = -16						; size = 4
_$S1$ = -12						; size = 4
_right$ = -8						; size = 4
_left$ = -4						; size = 4
_main	PROC
; File D:\srccode\cplusplusdemo\ComplieAndMem\reference\main.cpp
; Line 1
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; Line 2
	mov	DWORD PTR _left$[ebp], 255		; 000000ffH
; Line 3
	mov	DWORD PTR _right$[ebp], 65280		; 0000ff00H
; Line 4
	mov	eax, DWORD PTR _left$[ebp]
	add	eax, DWORD PTR _right$[ebp]
	mov	DWORD PTR _$S1$[ebp], eax
	lea	ecx, DWORD PTR _$S1$[ebp]
	mov	DWORD PTR _sum$[ebp], ecx
; Line 5
	xor	eax, eax
; Line 6
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
END

```

- 栈申请了16个字节
    - sub sub	esp, 16	
    - 分别存储
      - left
      - right
      - left+right的结果临时变量S1
      - sum
- left + right的结果放在栈里
- sum指向了临时变量S1
  - S1也在栈里，就在sum的前面
  - 

给代码加一下注解
```asm
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

	TITLE	D:\srccode\cplusplusdemo\ComplieAndMem\build\main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_main
; Function compile flags: /Odtp
_TEXT	SEGMENT
_sum$ = -16						; size = 4
_$S1$ = -12						; size = 4
_right$ = -8						; size = 4
_left$ = -4						; size = 4
_main	PROC
; File D:\srccode\cplusplusdemo\ComplieAndMem\reference\main.cpp
; Line 1
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H 给栈申请了16个字节空间（栈顶-16、栈由大到小扩展），存储四个变量（如上提示）：left、right、left+right的临时变量、引用sum
; Line 2
	mov	DWORD PTR _left$[ebp], 255		; 000000ffH
; Line 3
	mov	DWORD PTR _right$[ebp], 65280		; 0000ff00H
; Line 4
	mov	eax, DWORD PTR _left$[ebp]
	add	eax, DWORD PTR _right$[ebp]
	mov	DWORD PTR _$S1$[ebp], eax  ;把累加器的值放到S1。即栈在ebp-12的位置
	lea	ecx, DWORD PTR _$S1$[ebp]  ;将S1的值放到计数寄存器ecx
	mov	DWORD PTR _sum$[ebp], ecx  ;将ecx的值放到sum，即栈在ebp -16的位置
; Line 5
	xor	eax, eax
; Line 6
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
END

```
# 引用折叠
只有右右时为右，其他都为左
- 左左得左
- 左右得左
- 右左得左
- 右右得右
# std::move实现原理

std::move实现
- 通过remove_reference_t<_Ty>取得去掉引用后的类型type
- 通过static_cast将类型转换为右值
  - 取得类型后是static_cast<type&&>(_Arg)。
```C++
template <class _Ty>
_NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}
```
依赖的remove_reference_t<_Ty>
```C++
template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;
```
以下remove_reference中，无论转入的参数是_Ty、_Ty&、_Ty&&中的哪一种，remove_reference::type，都把引用去掉了。
比如remove_reference<int>(i)。无论变量i是int、int&、还是int&&，remove_reference<int>::type，都是int.
```C++
template <class _Ty>
struct remove_reference {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};
```

比如
```C++
int a = 1;
int &b = a;// b为左引用int&
int&& rc = std::move(b);
```
其中std::move(b)
是一个模板函数，
```C++
template <int&>
_NODISCARD constexpr remove_reference_t<int&>&& move(int& && _Arg) noexcept { // forward _Arg as movable
    return static_cast<remove_reference_t<int&>&&>(_Arg);
}
```
展开remove_reference_t<int&>
注意使用左引用版本
```C++
template <class int>
struct remove_reference<int&> {
    using type                 = int;
    using _Const_thru_ref_type = const int&;
};
```

则remove_reference<int&>::type为int，替换回move模板函数得到。
其中int& && _Arg通过引用折叠，变成int& _Arg.
```C++
template <int&>
_NODISCARD constexpr int&& move(int& _Arg) noexcept { // forward _Arg as movable
    return static_cast<int&&>(_Arg);
}
```

可以看到，最终是通过 static_cast进行的强转，通过模板类型remove_reference去掉引用，取得无引用类型。


# std::forward实现原理
是模板函数
- 函数参数去引用，组成左引用
  - 无论入参是什么，都会变成左引用
  - remove_reference_t<_Ty>& _Arg
    - 若具体类型为int，去引用后为int& _Arg
- 通过 static_cast<_Ty&&>(_Arg)强转
  - 入参为左引用
    - static_cast<int& &&>(_Arg)
    - 则转 int& &&，折叠后变int&
    - static_cast<int&>(_Arg)
  - 入参为右引用
    - static_cast<int&& &&>(_Arg)
    - 则转 int&& &&，折叠后变int&&
    - static_cast<int&&>(_Arg)
  - 入参为int
    - static_cast<int&& &&>(_Arg)
    - 直接强转转int&&


其是一个模板函数
```C++
template <class _Ty>
_NODISCARD constexpr _Ty&& forward(
    remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue
    return static_cast<_Ty&&>(_Arg);
}
```
比如
```c++
    int&& rRef = 1;            // 临时对象是右值
    std::forward<int>(rRef);
```
注意，参考上面remove_reference_t<_Ty>是去引用的。最终取到int。
当传和rRef为int&&时，
展开后就是
```C++
template <class int&&>
_NODISCARD constexpr int&& && forward(
    int & _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue
    return static_cast<int&& &&>(_Arg);
}
```
引用折叠后，变成
```C++
template <class int&&>
_NODISCARD constexpr int&& forward(
    int & _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue
    return static_cast<int&&>(_Arg);
}
```

而如果传入的是int&类型是
```C++
template <class _Ty>
_NODISCARD constexpr _Ty&& forward(
    remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue
    return static_cast<_Ty&&>(_Arg);
}
```
展开后
```C++
template <class int&>
_NODISCARD constexpr int& && forward(
    int & _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue
    return static_cast<int& &&>(_Arg);
}
```
引用折叠后，得到
```C++
template <class int&>
_NODISCARD constexpr int& forward(
    int & _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue
    return static_cast<int&>(_Arg);
}
```
即，传入的是int&，返回的也是int&





# 简版函数压栈
调用add的压栈顺序b-->a
先b入栈，然后a入栈。

从生成的汇编代码看，没有返回值的压栈。返回值直接通过寄存器eax返回了。更高效。

```C++
int add(int a, int b){
    return a + b;
}
int main() {
    int left = 0xff;
    int right = 0xff00;
    int sum = add(left, right);
    return 0;
}
```

```asm
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

	TITLE	D:\srccode\cplusplusdemo\ComplieAndMem\build\main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?add@@YAHHH@Z					; add
PUBLIC	_main
; Function compile flags: /Odtp
_TEXT	SEGMENT
_sum$ = -12						; size = 4
_left$ = -8						; size = 4
_right$ = -4						; size = 4
_main	PROC
; File D:\srccode\cplusplusdemo\ComplieAndMem\reference\main.cpp
; Line 4
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
; Line 5
	mov	DWORD PTR _left$[ebp], 255		; 000000ffH
; Line 6
	mov	DWORD PTR _right$[ebp], 65280		; 0000ff00H
; Line 7
	mov	eax, DWORD PTR _right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _left$[ebp]
	push	ecx
	call	?add@@YAHHH@Z				; add
	add	esp, 8
	mov	DWORD PTR _sum$[ebp], eax
; Line 8
	xor	eax, eax
; Line 9
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?add@@YAHHH@Z PROC					; add
; File D:\srccode\cplusplusdemo\ComplieAndMem\reference\main.cpp
; Line 1
	push	ebp
	mov	ebp, esp
; Line 2
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
; Line 3
	pop	ebp
	ret	0
?add@@YAHHH@Z ENDP					; add
_TEXT	ENDS
END

```

# 函数压栈
int add(int a, int b)

压栈顺序为从右至左，最后是返回值。

b->a->返回值


正面以

Sum add(int a, int b)

为例 

```C++
struct Sum {
    int l;
    int r;
    int h;
};
Sum add(int a, int b){
    Sum s;
    s.l = a;
    s.r = b;
    s.h = a;
    return s;
}
int main() {
    int left = 0xff;
    int right = 0xff00;
    Sum sum = add(left, right);
    return 0;
}
```

这里在关于Sum的构造的调用
- 在add中
  - Sum s。调用了一次构造函数
  - 在函数返回时调用了一次拷贝构造函数，将s1拷贝给临时变量T1
- 在main中
  - 将临时变量返回值T1，拷贝给T2，然后T2再给到sum.

```asm
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

	TITLE	D:\srccode\cplusplusdemo\ComplieAndMem\build\main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?add@@YA?AUSum@@HH@Z				; add
PUBLIC	_main
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_main
	DD	0dH
	DD	057H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?add@@YA?AUSum@@HH@Z
	DD	0dH
	DD	039H
voltbl	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
$T1 = -48						; size = 12
_left$ = -36						; size = 4
_right$ = -32						; size = 4
_sum$ = -28						; size = 12
$T2 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_main	PROC
; File D:\srccode\cplusplusdemo\ComplieAndMem\reference\main.cpp
; Line 13
	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
; Line 14
	mov	DWORD PTR _left$[ebp], 255		; 000000ffH
; Line 15
	mov	DWORD PTR _right$[ebp], 65280		; 0000ff00H
; Line 16
	mov	eax, DWORD PTR _right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _left$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	?add@@YA?AUSum@@HH@Z			; add
	add	esp, 12					; 0000000cH     弹出调用add的参数列表及返回值地址。
	mov	ecx, DWORD PTR [eax]				;add返回时，已把临时变量T1的地址给了eax。
	mov	DWORD PTR $T2[ebp], ecx             ;以下逻辑是T1值赋给T2,然后，T2赋值为sum
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp+8], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _sum$[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR _sum$[ebp+4], edx
	mov	eax, DWORD PTR $T2[ebp+8]
	mov	DWORD PTR _sum$[ebp+8], eax
; Line 17
	xor	eax, eax
; Line 18
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
_s$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
$T1 = 8							; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
?add@@YA?AUSum@@HH@Z PROC				; add
; File D:\srccode\cplusplusdemo\ComplieAndMem\reference\main.cpp
; Line 6
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
; Line 8
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _s$[ebp], eax
; Line 9
	mov	ecx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _s$[ebp+4], ecx
; Line 10
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR _s$[ebp+8], edx
; Line 11
	mov	eax, DWORD PTR $T1[ebp]    ;把add函数中的本地变量s，赋值给main的临时变量T1。这里取的是T1的地址给eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], ecx       ;把ecx的值传给eax指向的地址。这里eax加了[]
	mov	edx, DWORD PTR _s$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _s$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR $T1[ebp]    ;把T1地址放到寄存器eax
; Line 12
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]    ;add函数退出清理栈
	xor	ecx, ebp
	call	@__security_check_cookie@4      ;检查是否栈溢出
	mov	esp, ebp							;把栈底值ebp，赋给栈顶值esp。
	pop	ebp									;从栈中弹出值给ebp。（这里ebp的值，就是main函数的栈底）
	ret	0
?add@@YA?AUSum@@HH@Z ENDP				; add
_TEXT	ENDS
END

```